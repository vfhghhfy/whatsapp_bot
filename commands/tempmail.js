const fetch = require('node-fetch');

// Store active temp emails (in production, you'd want to use a database)
const activeTempEmails = new Map();

async function tempmailCommand(sock, chatId, message, args) {
    try {
        const command = args[0]?.toLowerCase();

        switch (command) {
            case 'generate':
            case 'gen':
                await generateTempEmail(sock, chatId, message);
                break;
            case 'inbox':
                await checkInbox(sock, chatId, message, args[1]);
                break;
            case 'read':
                await readMessage(sock, chatId, message, args[1], args[2]);
                break;
            case 'list':
                await listActiveEmails(sock, chatId, message);
                break;
            default:
                await showHelp(sock, chatId, message);
                break;
        }
    } catch (error) {
        console.error('Error in tempmail command:', error);
        await sock.sendMessage(chatId, {
            text: `âŒ *Temp Email Error*\n\n*Error:* ${error.message}\n\nPlease try again later.`
        }, { quoted: message });
    }
}

async function generateTempEmail(sock, chatId, message) {
    try {
        await sock.sendMessage(chatId, {
            text: 'ğŸ”„ Generating temporary email address...'
        }, { quoted: message });

        const response = await fetch('https://api.giftedtech.web.id/api/tempmail/generate?apikey=gifted');

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (!data.success || !data.result?.email) {
            throw new Error('Failed to generate email address');
        }

        const email = data.result.email;
        const userId = message.key.participant || message.key.remoteJid;

        // Store the email for this user
        activeTempEmails.set(userId, {
            email: email,
            createdAt: new Date(),
            lastChecked: null
        });

        const emailMessage = `ğŸ“§ *TEMPORARY EMAIL GENERATED* ğŸ“§\n\n`;
        const formattedMessage = emailMessage +
            `âœ‰ï¸ *Email:* \`${email}\`\n\n` +
            `â° *Expires:* 10 minutes\n` +
            `ğŸ“ *Note:* ${data.result.message}\n\n` +
            `ğŸ”§ *Commands:*\n` +
            `â€¢ \`.tempmail inbox\` - Check inbox\n` +
            `â€¢ \`.tempmail list\` - Show your emails\n\n` +
            `âš¡ Generated by GiftedTech API`;

        const buttons = [
            { buttonId: '.tempmail inbox', buttonText: { displayText: 'ğŸ“¬ Check Inbox' }, type: 1 },
            { buttonId: '.tempmail gen', buttonText: { displayText: 'ğŸ”„ New Email' }, type: 1 }
        ];

        await sock.sendMessage(chatId, {
            text: formattedMessage,
            buttons: buttons,
            headerType: 1
        }, { quoted: message });

    } catch (error) {
        throw new Error(`Failed to generate email: ${error.message}`);
    }
}

async function checkInbox(sock, chatId, message, customEmail) {
    try {
        const userId = message.key.participant || message.key.remoteJid;
        let emailToCheck = customEmail;

        if (!emailToCheck) {
            const userEmail = activeTempEmails.get(userId);
            if (!userEmail) {
                await sock.sendMessage(chatId, {
                    text: 'âŒ No active temp email found. Generate one first with `.tempmail generate`'
                }, { quoted: message });
                return;
            }
            emailToCheck = userEmail.email;
        }

        await sock.sendMessage(chatId, {
            text: `ğŸ”„ Checking inbox for ${emailToCheck}...`
        }, { quoted: message });

        const response = await fetch(`https://api.giftedtech.web.id/api/tempmail/inbox?apikey=gifted&email=${encodeURIComponent(emailToCheck)}`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (!data.success) {
            throw new Error('Failed to check inbox');
        }

        // Update last checked time
        if (activeTempEmails.has(userId)) {
            activeTempEmails.get(userId).lastChecked = new Date();
        }

        if (data.message && data.message.includes('No Emails Received Yet')) {
            const noMailMessage = `ğŸ“¬ *INBOX EMPTY* ğŸ“¬\n\n` +
                `âœ‰ï¸ *Email:* \`${emailToCheck}\`\n` +
                `ğŸ“­ *Status:* No emails received yet\n\n` +
                `ğŸ’¡ *Tip:* Send a test email and wait 10 seconds before checking again\n\n` +
                `â° Last checked: ${new Date().toLocaleTimeString()}`;

            const buttons = [
                { buttonId: '.tempmail inbox', buttonText: { displayText: 'ğŸ”„ Refresh Inbox' }, type: 1 },
                { buttonId: '.tempmail gen', buttonText: { displayText: 'ğŸ“§ New Email' }, type: 1 }
            ];

            await sock.sendMessage(chatId, {
                text: noMailMessage,
                buttons: buttons,
                headerType: 1
            }, { quoted: message });
        } else if (data.result && Array.isArray(data.result)) {
            let inboxMessage = `ğŸ“¬ *INBOX - ${data.result.length} MESSAGE(S)* ğŸ“¬\n\n`;
            inboxMessage += `âœ‰ï¸ *Email:* \`${emailToCheck}\`\n\n`;

            data.result.forEach((email, index) => {
                inboxMessage += `*${index + 1}.* ${email.subject || 'No Subject'}\n`;
                inboxMessage += `   ğŸ‘¤ From: ${email.from || 'Unknown'}\n`;
                inboxMessage += `   ğŸ“… Date: ${email.date || 'Unknown'}\n`;
                if (email.messageId) {
                    inboxMessage += `   ğŸ†” ID: \`${email.messageId}\`\n`;
                }
                inboxMessage += `\n`;
            });

            inboxMessage += `ğŸ”§ *Commands:*\n`;
            inboxMessage += `â€¢ \`.tempmail read <messageId>\` - Read message\n`;
            inboxMessage += `â€¢ \`.tempmail inbox\` - Refresh inbox\n\n`;
            inboxMessage += `â° Last checked: ${new Date().toLocaleTimeString()}`;

            const buttons = [
                { buttonId: '.tempmail inbox', buttonText: { displayText: 'ğŸ”„ Refresh' }, type: 1 },
                { buttonId: '.tempmail gen', buttonText: { displayText: 'ğŸ“§ New Email' }, type: 1 }
            ];

            await sock.sendMessage(chatId, {
                text: inboxMessage,
                buttons: buttons,
                headerType: 1
            }, { quoted: message });
        }

    } catch (error) {
        throw new Error(`Failed to check inbox: ${error.message}`);
    }
}

async function readMessage(sock, chatId, message, messageId, customEmail) {
    try {
        if (!messageId) {
            await sock.sendMessage(chatId, {
                text: 'âŒ Please provide a message ID. Use `.tempmail inbox` to see message IDs.'
            }, { quoted: message });
            return;
        }

        const userId = message.key.participant || message.key.remoteJid;
        let emailToUse = customEmail;

        if (!emailToUse) {
            const userEmail = activeTempEmails.get(userId);
            if (!userEmail) {
                await sock.sendMessage(chatId, {
                    text: 'âŒ No active temp email found. Please specify email or generate one first.'
                }, { quoted: message });
                return;
            }
            emailToUse = userEmail.email;
        }

        await sock.sendMessage(chatId, {
            text: `ğŸ”„ Reading message ${messageId}...`
        }, { quoted: message });

        const response = await fetch(`https://api.giftedtech.web.id/api/tempmail/message?apikey=gifted&email=${encodeURIComponent(emailToUse)}&messageid=${encodeURIComponent(messageId)}`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (!data.success) {
            throw new Error('Failed to read message');
        }

        const messageData = data.result;
        let readMessage = `ğŸ“§ *EMAIL MESSAGE* ğŸ“§\n\n`;
        readMessage += `âœ‰ï¸ *To:* \`${emailToUse}\`\n`;
        readMessage += `ğŸ‘¤ *From:* ${messageData.from || 'Unknown'}\n`;
        readMessage += `ğŸ“‹ *Subject:* ${messageData.subject || 'No Subject'}\n`;
        readMessage += `ğŸ“… *Date:* ${messageData.date || 'Unknown'}\n\n`;
        readMessage += `ğŸ“ *Content:*\n${messageData.body || messageData.text || 'No content available'}\n\n`;
        readMessage += `ğŸ†” *Message ID:* \`${messageId}\``;

        const buttons = [
            { buttonId: '.tempmail inbox', buttonText: { displayText: 'ğŸ“¬ Back to Inbox' }, type: 1 },
            { buttonId: '.tempmail gen', buttonText: { displayText: 'ğŸ“§ New Email' }, type: 1 }
        ];

        await sock.sendMessage(chatId, {
            text: readMessage,
            buttons: buttons,
            headerType: 1
        }, { quoted: message });

    } catch (error) {
        throw new Error(`Failed to read message: ${error.message}`);
    }
}

async function listActiveEmails(sock, chatId, message) {
    try {
        const userId = message.key.participant || message.key.remoteJid;
        const userEmail = activeTempEmails.get(userId);

        if (!userEmail) {
            await sock.sendMessage(chatId, {
                text: 'ğŸ“­ No active temporary emails found.\n\nUse `.tempmail generate` to create one.'
            }, { quoted: message });
            return;
        }

        const timeSinceCreated = Math.floor((new Date() - userEmail.createdAt) / 1000 / 60);
        const timeLeft = Math.max(0, 10 - timeSinceCreated);

        let listMessage = `ğŸ“§ *YOUR TEMP EMAILS* ğŸ“§\n\n`;
        listMessage += `âœ‰ï¸ *Email:* \`${userEmail.email}\`\n`;
        listMessage += `ğŸ“… *Created:* ${userEmail.createdAt.toLocaleTimeString()}\n`;
        listMessage += `â° *Time Left:* ${timeLeft} minutes\n`;
        if (userEmail.lastChecked) {
            listMessage += `ğŸ” *Last Checked:* ${userEmail.lastChecked.toLocaleTimeString()}\n`;
        }
        listMessage += `\nğŸ”§ *Quick Actions:*\n`;
        listMessage += `â€¢ \`.tempmail inbox\` - Check inbox\n`;
        listMessage += `â€¢ \`.tempmail generate\` - New email`;

        const buttons = [
            { buttonId: '.tempmail inbox', buttonText: { displayText: 'ğŸ“¬ Check Inbox' }, type: 1 },
            { buttonId: '.tempmail gen', buttonText: { displayText: 'ğŸ”„ New Email' }, type: 1 }
        ];

        await sock.sendMessage(chatId, {
            text: listMessage,
            buttons: buttons,
            headerType: 1
        }, { quoted: message });

    } catch (error) {
        throw new Error(`Failed to list emails: ${error.message}`);
    }
}

async function showHelp(sock, chatId, message) {
    const helpMessage = `ğŸ“§ *TEMP EMAIL COMMANDS* ğŸ“§\n\n` +
        `ğŸ”§ *Available Commands:*\n\n` +
        `â€¢ \`.tempmail generate\` or \`.tempmail gen\`\n` +
        `  Generate a new temporary email\n\n` +
        `â€¢ \`.tempmail inbox [email]\`\n` +
        `  Check inbox (uses your active email if no email specified)\n\n` +
        `â€¢ \`.tempmail read <messageId> [email]\`\n` +
        `  Read a specific message\n\n` +
        `â€¢ \`.tempmail list\`\n` +
        `  Show your active temporary emails\n\n` +
        `âš ï¸ *Note:* Emails expire after 10 minutes\n` +
        `âš¡ Powered by GiftedTech API`;

    const buttons = [
        { buttonId: '.tempmail generate', buttonText: { displayText: 'ğŸ“§ Generate Email' }, type: 1 },
        { buttonId: '.help', buttonText: { displayText: 'ğŸ“‹ Main Help' }, type: 1 }
    ];

    await sock.sendMessage(chatId, {
        text: helpMessage,
        buttons: buttons,
        headerType: 1
    }, { quoted: message });
}

module.exports = tempmailCommand;
